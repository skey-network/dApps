{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let NONE = "none"
let BANNED = "banned" # do we need it?
let ACTIVE = "active"
let CLOSE = "close"
let OPEN = "open"
let deviceActiveKey = "active"
let deviceConnectedKey = "connected"
let assetKey = "asset"
let keyPriceKey = "key_price"
let ownerKey = "owner"
let organizationKey = "org_"
let organizationUserKey = "user_"
let rechargeLimitKey = "recharge_limit"
let dappFatherKey = "dapp_father"
# let actions = [OPEN, CLOSE]
let deviceInitialCounter = 0
#let KEY_DAPP=0 - use issuer
let keyDeviceIndex = 0
let keyValidUntilIndex = 1
let keyVersionIndex = 2
let oneMinute = 60000 # in miliseconds
let version1 = "v1"

let mobileIdWildcard = "*"
let mobileIdUnset = "?"


################ utx etc

  func getNumberByKey(key: String) = {
    match getInteger(this,key){
      case a:Int => a
      case _ => 0
    }
  }
  func getStrByKey(key: String) = {
    match getString(this,key){
      case a:String => a
      case _ => NONE
    }
  }
  func getExtNumberByKey(key: String) = {
    match getInteger(this,key){
      case a:Int => a
      case _ => 0
    }
  }
  func getExtStrByKey(addr: Address, key: String) = {
    match getString(addr,key){
      case a:String => a
      case _ => NONE
    }
  }
  func getExtBoolByKey(addr: Address, key: String) = {
    match getBoolean(addr,key){
      case a:Boolean => a
      case _ => false
    }
  }
  func getAssetId()={
    fromBase58String(getStrByKey(assetKey))
  }
################# dapp - user keys/values

  func userStatusKey(addr:String)={
    "user_"+addr
  }

  # values: "none", "active", "banned"
  func userStatusValue(addr:String)={
    match getString(this,userStatusKey(addr)){
      case a:String => a
      case _ => NONE
    }
  }
################# dapp - device keys/values

  func deviceActionKey(addr:String)={
    "device_"+addr
  }
  func deviceActionCounterKey(addr:String)={
    "device_counter_"+addr
  }
  # values: "none", "open", "closed"
  func deviceActionValue(addr:String)={
    getStrByKey(deviceActionKey(addr))
  }
  func deviceActionCounterValue(addr:String)={
    getNumberByKey(deviceActionCounterKey(addr))
  }

################# dapp - device key/nft keys/values
  func nftKey(nft:String)={
    "key_"+nft
  }

  func nftValue(nft:String)={
    getStrByKey(nftKey(nft))
  }

################### returns device if key is whitelisted, otherwise none
  func deviceNotWhitelistedKey(device: Address, key: String)={
    let nftId = nftKey(key)
    let valInDevice = getExtStrByKey(device, nftId)
    valInDevice != ACTIVE
  }


  func deviceFromKey(key: Asset)={
    let device = key.description.split("_")[keyDeviceIndex]
    match (addressFromString(device)){
      case t:Address => t
      case _ => throw("Not a device key")
    }
  }

   func versionFromKey(key: Asset)={
    key.description.split("_")[keyVersionIndex]
  }

  func getAssetInfo(asset:ByteVector)={
    match (assetInfo(asset)) {
        case t:Asset => t 
        case _ => throw("Not a key")
      }
  }

  func keyTimestampInvalid(key:Asset)={
    let timestamp = parseIntValue(key.description.split("_")[keyValidUntilIndex])
    timestamp < lastBlock.timestamp
  }

  func keyPriceFromDevice(device: Address)={
    match(getInteger(device,keyPriceKey)){
      case t:Int => t
      case _ => throw("Price not specified in device")
    }
  }

  func ownerFromDevice(device: Address)={
    match(getString(device,ownerKey)){
      case t:String => t
      case _ => throw("Owner not specified in device")
    }
  }

  # checks for: 
  # not allowed asset
  # wrong amount
  func priceIsWrong(i:Invocation, assetId:ByteVector, price: Int)={
    if(i.payments.size() < 1) then throw("wrong payments count")
    else if(i.payments[0].assetId != unit) then throw("wrong asset, supported only wws")
    else if(i.payments[0].amount != price) then throw("wrong payment value, expected " + toString(price))
    else false
  }


  func getAssetIdFromAttachedPayment(p:AttachedPayment)={
    match(p.assetId){
      case t:ByteVector => t
      case _ => throw("Wrong asset")
    }
  }

  func getAssetInfoFromPayment(i:Invocation)={
    if(i.payments.size() != 1) then throw("wrong assets count")
    else {
      let asset = getAssetInfo(getAssetIdFromAttachedPayment(i.payments[0]))
      if(asset.issuer != this) then throw("wrong asset issuer")
      else if(keyTimestampInvalid(asset)) then throw("key expired")
      else{
        asset
      }
    }
  }

  func rechargeIfNeeded(account:Address)={
    # let recharge = getExtNumberByKey(rechargeLimitKey)
    let dappFather = getStrByKey(dappFatherKey)
    # if(recharge > 0 && wavesBalance(account).regular < recharge && recharge != 0) then {
      invoke(addressFromStringValue(dappFather), "refill", [toBase58String(account.bytes)], [])!=unit 
      # ScriptTransfer(account, recharge, unit) :: []
    # } else {
      #  false
    # }
  }

  func organizationWhitelisted(organization:String)={
    let status = getStrByKey(organizationKey+organization)
    if(status != ACTIVE)then throw("Organization not permitted") else true
  }

  func whitelistedByOrganization(org:Address, caller:String, mobileId:String)={
    let definedMobileId = getExtStrByKey(org,organizationUserKey+caller)
    if(definedMobileId == NONE)then throw("Not permitted by organization")
    else if(definedMobileId == mobileIdUnset) then throw("Mobile id not set")
    else if(definedMobileId == mobileIdWildcard) then true
    else if(definedMobileId != mobileId) then throw("Id mismatch")#+definedMobileId+" "+mobileId)
    else true
  }


################# utx - checks
  
  # checks if action is on predefined list
  # func notAllowedDeviceAction(action:String)={
  #   match (actions.indexOf(action)){
  #     case a:Int => false
  #     case _ => true
  #   }
  # }
################ public functions

### open device func
func deviceActionWithKey(i: Invocation, keyID: String, action: String) = {
  let keyInfo = getAssetInfo(fromBase58String(keyID))
  let device = deviceFromKey(keyInfo)
  # let keyVersion = versionFromKey(keyInfo)
  let deviceStr = toBase58String(device.bytes)
  let recharge = getExtNumberByKey(rechargeLimitKey)



  if(keyInfo.issuer != this) then throw("Wrong key issuer")
  # else if(keyVersion != version1) then throw("Wrong key version")
  else if(deviceActionKey(deviceStr)==NONE) then throw("No such device")
  else if(deviceNotWhitelistedKey(device, keyID)) then throw("Key not whitelisted")
  else if(!getExtBoolByKey(device, deviceConnectedKey))then throw("Device not connected")
  else if(!getExtBoolByKey(device, deviceActiveKey))then throw("Device not active")
  # else if(notAllowedDeviceAction(action)) then throw("Action is not allowed")
  else if(keyTimestampInvalid(keyInfo)) then throw("Key expired")
  else {
    let changes = [
      StringEntry(deviceActionKey(deviceStr), action),
      IntegerEntry(deviceActionCounterKey(deviceStr), deviceActionCounterValue(deviceStr) + 1)
    ] 
    (changes, rechargeIfNeeded(i.caller))
  }
}

###
#
# Updates device entries:
# - device_{address}: action      # action to be made
# - device_counter_{address} +1   # counter incremented with each action, change detected by oracle
#
@Callable(i)
func deviceActionAs(keyID: String, action: String, keyOwner: String, mobileId:String) = {
  let keyOwnerAddress = addressFromStringValue(keyOwner)
  let hasNoKey = assetBalance(keyOwnerAddress, fromBase58String(keyID)) < 1 # organisation has no key
  let allowedByKeyOwner = organizationWhitelisted(keyOwner) && whitelistedByOrganization(keyOwnerAddress, toBase58String(i.caller.bytes), mobileId)

  if (hasNoKey) then throw("Key not owned")
  else if(!allowedByKeyOwner) then throw("Not permitted")
  else deviceActionWithKey(i,keyID, action) 
}

###
#
# Updates device entries:
# - device_{address}: action      # action to be made
# - device_counter_{address} +1   # counter incremented with each action, change detected by oracle
#
@Callable(i)
func deviceAction(keyID: String, action: String) = {
  let keyOwnerAddress = i.caller
  let hasNoKey = assetBalance(keyOwnerAddress, fromBase58String(keyID)) < 1 # organisation has no key
  
  if (hasNoKey) then throw("Key not owned")
  else deviceActionWithKey(i,keyID, action) 
}

###
#
# Sends key and refils (as needed) account of sender and recipient
#
@Callable(i)
func transferKey(recipient: String) ={
  let keyInfo = getAssetInfoFromPayment(i) # throws errors when wrong issuer or key is expired
  let recipientAddr = addressFromStringValue(recipient)
  let transfer = ScriptTransfer(recipientAddr,1,keyInfo.id)::[]
  (transfer, rechargeIfNeeded(recipientAddr) && rechargeIfNeeded(i.caller)) # transfer and recharge if needed
}

@Callable(i)
func requestKey(deviceAddr: String, duration: Int) = {
  let issuedAt=lastBlock.timestamp
  let validUntil=issuedAt + duration * oneMinute
  let deviceOwner = ownerFromDevice(addressFromStringValue(deviceAddr))
  let keyPriceConstant = keyPriceFromDevice(addressFromStringValue(deviceAddr)) # throws if no price is specified
  let keyPrice = keyPriceConstant * duration
  let assetId = getAssetId()

  if(toBase58String(i.caller.bytes)!=deviceOwner)then throw("Not permitted")
  else if(deviceActionKey(deviceAddr)==NONE) then throw("No such device")
  else if(priceIsWrong(i,assetId,keyPrice))then throw("wrong price")
  else{
    let issue = Issue("SmartKey",deviceAddr+"_"+validUntil.toString()+"_"+version1,1,0,false) # timestamp of issue is in token details
    let newAssetId = calculateAssetId(issue)
    ([
      issue,
      ScriptTransfer(i.caller,1,newAssetId)
    ], rechargeIfNeeded(i.caller))
  } 
}
